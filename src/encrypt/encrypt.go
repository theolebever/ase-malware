package encrypt

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func Encrypt(inputFile, key, iv, mode string) error {
	// Read the file
	plaintext, err := ioutil.ReadFile(inputFile)
	if err != nil {
		return err
	}

	fmt.Println("[+] the key is: ", string(key))

	// Convert the key to a byte array
	keyBytes, err := hex.DecodeString(key)
	if err != nil {
		fmt.Println("Error: ", err)
		return err
	}

	// Create a new cipher block
	block, err := aes.NewCipher(keyBytes)
	if err != nil {
		fmt.Println("Error: ", err)
		return err
	}

	// Create a new GCM
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return err
	}

	nonce := make([]byte, 12)
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return err
	}

	// Encrypt the file
	result := gcm.Seal(nonce, nonce, plaintext, nil)

	// Delete the original file
	err = os.Remove(inputFile)
	if err != nil {
		return err
	}

	// Remove the extension of the file name
	inputFile = strings.TrimSuffix(inputFile, filepath.Ext(inputFile))

	// Create the output filename with .fic2023 extension
	var outputFile = inputFile + ".fic2024"

	// Write the result to the output file
	err = ioutil.WriteFile(outputFile, result, 0644)
	if err != nil {
		return err
	}

	return nil
}
