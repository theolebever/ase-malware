package encrypt

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"
)

func Encrypt(inputFile, key, iv, mode string) error {
	// Read the file
	plaintext, err := ioutil.ReadFile(inputFile)
	if err != nil {
		return err
	}

	// Reencode the string to UTF-8
	newkey := []byte(strings.ToValidUTF8(key, ""))

	// Create a new cipher block
	block, err := aes.NewCipher(newkey)
	if err != nil {
		fmt.Println("Error: ", err)
		return err
	}

	// Create a new GCM
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return err
	}

	nonce := make([]byte, 12)
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return err
	}

	// Encrypt the file
	result := gcm.Seal(nonce, nonce, plaintext, nil)

	// Delete the original file
	err = os.Remove(inputFile)
	if err != nil {
		return err
	}

	// Create the output filename with .fic2024 extension
	var outputFile = inputFile + ".fic2024"

	// Write the result to the output file
	err = ioutil.WriteFile(outputFile, result, 0644)
	if err != nil {
		return err
	}

	return nil
}

func Decrypt(inputFile, key, iv, mode string) error {
	// Read the file
	ciphertext, err := ioutil.ReadFile(inputFile)
	if err != nil {
		return err
	}

	// Reencode the string to UTF-8
	newkey := []byte(strings.ToValidUTF8(key, ""))

	// Create a new cipher block
	block, err := aes.NewCipher(newkey)
	if err != nil {
		fmt.Println("Error: ", err)
		return err
	}

	// Create a new GCM
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return err
	}

	// Check the length of the ciphertext
	if len(ciphertext) < gcm.NonceSize() {
		return fmt.Errorf("ciphertext is too short")
	}

	// Extract the nonce from the ciphertext
	nonce, ciphertext := ciphertext[:gcm.NonceSize()], ciphertext[gcm.NonceSize():]

	// Decrypt the file
	plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return err
	}

	// Delete the original encrypted file
	err = os.Remove(inputFile)
	if err != nil {
		return err
	}

	// Remove the .fic2024 extension from the file name
	inputFile = strings.TrimSuffix(inputFile, ".fic2024")

	// Create the output filename without .fic2024 extension
	var outputFile = inputFile

	// Write the result to the output file
	err = ioutil.WriteFile(outputFile, plaintext, 0644)
	if err != nil {
		return err
	}

	return nil
}
