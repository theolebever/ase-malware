package encrypt

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"io"
	"io/ioutil"
	"os"
)

func Encrypt(inputFile, key, iv, mode string) error {

	fmt.Println("Encrypting the file...")
	// Read the file
	plaintext, err := ioutil.ReadFile(inputFile)
	if err != nil {
		return err
	}

	fmt.Println("File read")

	// Convert the key to a byte array
	keyBytes, err := hex.DecodeString(key)
	if err != nil {
		fmt.Println("Error: ", err)
		return err
	}

	// Create a new cipher block
	block, err := aes.NewCipher(keyBytes)
	fmt.Println("New cipher block created")
	if err != nil {
		fmt.Println("Error: ", err)
		return err
	}

	// Create a new GCM
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return err
	}

	nonce := make([]byte, 12)
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return err
	}

	fmt.Printf("Encrypting the file %s...\n", inputFile)
	// Encrypt the file
	result := gcm.Seal(nonce, nonce, plaintext, nil)

	// Delete the original file
	err = os.Remove(inputFile)
	if err != nil {
		return err
	}

	fmt.Printf("%s file deleted\n", inputFile)

	// Create the output filename with .fic2023 extension
	var outputFile = inputFile + ".fic2024"

	fmt.Printf("Writing the result to %s...\n", outputFile)

	// Write the result to the output file
	err = ioutil.WriteFile(outputFile, result, 0644)
	if err != nil {
		return err
	}

	fmt.Println("Done!")
	return nil
}
